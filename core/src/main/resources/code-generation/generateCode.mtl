[comment encoding = UTF-8 /]
[module generateCode('http://www.example.org/RestAssured')]

[template public generateTestScenario(testScenario : TestScenario)]
	[comment @main /]
	[file (testScenario.testScenarioName.concat('.java'), false, 'UTF-8')]
package com.mdd.test;

import java.util.Map;
import java.util.HashMap;
import java.nio.file.Files;
import java.nio.file.Paths;
import org.apache.commons.text.StringSubstitutor;
import com.moandjiezana.toml.Toml;
import io.restassured.RestAssured;
import io.restassured.response.ValidatableResponse;

public class Test {

    Map<String, Object> paramsMap = new HashMap();

    public Test(String configFile) {
        try {
            String paramsFileContent = new String(Files.readAllBytes(Paths.get(configFile)));
            paramsMap = new Toml().read(paramsFileContent).toMap();
        } catch (Exception e) {
            System.out.println("Could not read TOML config file");
        }
    }

	public void test() {
		[for (testRoundtrip : TestRoundtrip | testScenario.testroundtrip) separator('\n\n') ]
		ValidatableResponse [testRoundtrip.testRoundtripName/] = RestAssured.given()
            [comment]
                .mtl content that did not work (square brackets are disallowed in comments, so I changed them)
                (if (testRoundtrip.requestspecification.authenticationScheme.oclIsTypeOf(BasicAuthScheme)))
                    (let basicAuthScheme : BasicAuthScheme = testRoundtrip.requestspecification.authenticationScheme.oclAsType(BasicAuthScheme))
                        .auth().basic((basicAuthScheme.user/), (basicAuthScheme.password/))
                    (/let)
                (/if)
            [/comment]
			[for (rd : String | testRoundtrip.requestspecification.requestDatum)]
				.param([rd/], [rd/])
			[/for]
			.when()
				.request("[testRoundtrip.requestspecification.method/]", StringSubstitutor.replace("[testRoundtrip.requestspecification.url/]", paramsMap))
			.then()
				[let responseSpecification : ResponseSpecification = testRoundtrip.responsespecification]
					.assertThat();
					[if (responseSpecification.statusmatcher->notEmpty())]
						[if (responseSpecification.statusmatcher.oclIsTypeOf(IsIn))]
							[let statusCode : IsIn = responseSpecification.statusmatcher.oclAsType(IsIn)]
								.statusCode(in([statusCode.value/])
							[/let]
						[/if]
					[/if]
					[if (responseSpecification.bodymatchergroup->notEmpty())]
						[for (matcher : BodyMatcher | responseSpecification.bodymatchergroup)]
						    [if (matcher.oclIsTypeOf(HasXPath))]
								[let bodyXPath : HasXPath = matcher.oclAsType(HasXPath)]
									.body([bodyXPath.xPath/]) //Todo: needs correction after dealing with the inheritance
								[/let]
							[/if]
							[if (matcher.oclIsTypeOf(IsIn))]
								[let bodyIsIn : IsIn = matcher.oclAsType(IsIn)]
									//Todo: is this needed?
								[/let]
							[/if]
							[if (testRoundtrip.responsespecification.responsedatum->notEmpty())]
								.and().extract().response()
							[/if]
						[/for]
					[/if]
				[/let];

			[for (responseDatum : ResponseDatum | testRoundtrip.responsespecification.responsedatum)]
				String [responseDatum.responseDatumName/] = [responseDatum.responseDatumName/].path("[responseDatum.responseDatumXPath/]");
			[/for]
		[/for]
	}
}
	[/file]
[/template]

[template private generateTestRoundtrip(testRoundTrip : TestRoundtrip) ]
	
[/template]
