modeltype puml "strict" uses puml('http://www.eclipse.plantuml/Puml');
modeltype reqres "strict" uses RequestResponsePairs('http://www.example.org/RequestResponsePairs');
modeltype Ecore "strict" uses 'http://www.eclipse.org/emf/2002/Ecore';

configuration property diagramName : String;

transformation puml2reqres(in input: puml, out output: reqres);

main() {
    log('Started transforming PlantUML to RequestResponse pairs');
    log(diagramName);

    assert fatal ( input.objectsOfType(UmlDiagram).umlDiagrams[SequenceUml]->size() = 1 )
        with log('Input does not contain exactly one SequenceDiagram');

     input.objectsOfType(UmlDiagram).umlDiagrams[SequenceUml].map transformUmlDiagram();
}

mapping SequenceUml::transformUmlDiagram(): Scenario {
    scenarioName := diagramName;

    var roundtripId : Integer := 1;

    var umlElements : OrderedSet(SequenceElement) := self.umlElements->flattenSequenceElements();
    var umlElementsSize : Integer := umlElements->size();
    var umlElementsIndex : Integer := 1;
    log ("", umlElementsSize);
    while (umlElementsIndex <= umlElementsSize) {
        var sequenceElement : SequenceElement := umlElements->at(umlElementsIndex);
        if (sequenceElement.oclIsTypeOf(UseLeft)) {

            var useLeft : UseLeft := sequenceElement.oclAsType(UseLeft);
            assert fatal ( useLeft.content != null )
                with log ( 'UseLeft needs to contain content');
            var requestresponse : RequestResponse := useLeft.content;
            assert fatal ( requestresponse.oclIsTypeOf(Request) )
                with log ( 'Requestresponse needs to be a request');
            var request : Request := requestresponse.oclAsType(Request);
            var httpRequestElement : HttpRequest := request.request2httpRequest();
            httpRequestElement.receiver := useLeft.userTwo.name;
            var httpRequestElementCopy : HttpRequest := new HttpRequest();
            httpRequestElementCopy.httpMethod := httpRequestElement.httpMethod;
            httpRequestElementCopy.url := httpRequestElement.url;
            httpRequestElementCopy.httprequestdatum := httpRequestElement.httprequestdatum;
            httpRequestElementCopy.receiver := httpRequestElement.receiver;

            umlElementsIndex := umlElementsIndex + 1;
            sequenceElement := umlElements->at(umlElementsIndex);
            log("Was here");
            if (sequenceElement.oclIsTypeOf(UseLeft)) {
                log("Was useLeft");
                useLeft := sequenceElement.oclAsType(UseLeft);
                assert fatal ( useLeft.content != null )
                    with log ( 'UseLeft needs to contain content');
                requestresponse := useLeft.content;
                assert fatal ( requestresponse.oclIsTypeOf(Response) )
                    with log ( 'Requestresponse needs to be a response');
                var response : Response := requestresponse.oclAsType(Response);
                var httpResponseElement : HttpResponse := response.response2httpResponse();

                var roundtripElement : Roundtrip := new Roundtrip();
                roundtripElement.roundtripName := "roundtrip" + roundtripId.toString();
                roundtripElement.httprequest := httpRequestElement;
                roundtripElement.httpresponse := httpResponseElement;

                roundtrip += roundtripElement;
                roundtripId := roundtripId + 1;
            }
            elif (sequenceElement.oclIsTypeOf(Alternative)) {
                log("HEELLOO");
                var alternative : Alternative := sequenceElement.oclAsType(Alternative);
                useLeft := alternative.umlElements->at(1).oclAsType(UseLeft);
                assert fatal ( useLeft.content != null )
                    with log ( 'UseLeft needs to contain content');
                requestresponse := useLeft.content;
                assert fatal ( requestresponse.oclIsTypeOf(Response) )
                    with log ( 'Requestresponse needs to be a response');
                var response : Response := requestresponse.oclAsType(Response);
                var httpResponseElement : HttpResponse := response.response2httpResponse();

                var roundtripElement : Roundtrip := new Roundtrip();
                roundtripElement.roundtripName := "roundtrip" + roundtripId.toString();
                roundtripElement.precondition := alternative.text;
                roundtripElement.httprequest := httpRequestElement;
                roundtripElement.httpresponse := httpResponseElement;

                roundtrip += roundtripElement;
                roundtripId := roundtripId + 1;


                var elseElement : Else := alternative.elseBlocks->at(1).oclAsType(Else);
                useLeft := elseElement.umlElements->at(1).oclAsType(UseLeft);
                assert fatal ( useLeft.content != null )
                    with log ( 'UseLeft needs to contain content');
                requestresponse := useLeft.content;
                assert fatal ( requestresponse.oclIsTypeOf(Response) )
                    with log ( 'Requestresponse needs to be a response');
                response := requestresponse.oclAsType(Response);
                httpResponseElement := response.response2httpResponse();

                roundtripElement := new Roundtrip();
                roundtripElement.roundtripName := "roundtrip" + roundtripId.toString();
                roundtripElement.precondition := elseElement.text;

                roundtripElement.httprequest := httpRequestElementCopy;
                roundtripElement.httpresponse := httpResponseElement;

                roundtrip += roundtripElement;
                roundtripId := roundtripId + 1;

            }
        }
        elif (sequenceElement.oclIsTypeOf(Alternative)) {
            var alternative : Alternative := sequenceElement.oclAsType(Alternative);
            var useLeft : UseLeft := alternative.umlElements->at(1).oclAsType(UseLeft);
            assert fatal ( useLeft.content != null )
                with log ( 'UseLeft needs to contain content');
            var requestresponse : RequestResponse := useLeft.content;
            assert fatal ( requestresponse.oclIsTypeOf(Request) )
                with log ( 'Requestresponse needs to be a request');
            var request : Request := requestresponse.oclAsType(Request);
            var httpRequestElement : HttpRequest := request.request2httpRequest();

            useLeft := alternative.umlElements->at(2).oclAsType(UseLeft);
            assert fatal ( useLeft.content != null )
                with log ( 'UseLeft needs to contain content');
            requestresponse := useLeft.content;
            assert fatal ( requestresponse.oclIsTypeOf(Response) )
                with log ( 'Requestresponse needs to be a response');
            var response : Response := requestresponse.oclAsType(Response);
            var httpResponseElement : HttpResponse := response.response2httpResponse();

            var roundtripElement : Roundtrip := new Roundtrip();
            roundtripElement.roundtripName := "roundtrip" + roundtripId.toString();
            roundtripElement.precondition := alternative.text;

            roundtripElement.httprequest := httpRequestElement;
            roundtripElement.httpresponse := httpResponseElement;

            roundtrip += roundtripElement;
            roundtripId := roundtripId + 1;
        };
        umlElementsIndex := umlElementsIndex + 1;
    };


}

helper OrderedSet(SequenceElement)::flattenSequenceElements():OrderedSet(SequenceElement) {
    var sequenceElements : OrderedSet(SequenceElement);
    log("START", self->size());
    self->forEach(umlElement) {
        if (umlElement.oclIsTypeOf(UseLeft)) {
            var useLeft : UseLeft := umlElement.oclAsType(UseLeft);
            log("Before", sequenceElements->size());
            sequenceElements += useLeft;
            log("Added useLeft", sequenceElements->size());
        }
        elif (umlElement.oclIsTypeOf(Alternative)) {
            log("WAS ALTERNATIVE");
            var alternative : Alternative := umlElement.oclAsType(Alternative);
            // alternative.umlElements += alternative.umlElements->flattenSequenceElements();
            // sequenceElements += alternative.umlElements->flattenSequenceElements();
            sequenceElements += alternative.map flattenAlternative();
            log("Added alternative", sequenceElements->size());
        }
        elif (umlElement.oclIsTypeOf(Activate)) {
        log("Was activate");
            var activate : Activate := umlElement.oclAsType(Activate);
            /*(activate.umlElements->flattenSequenceElements())->forEach(sequenceElement) {
                sequenceElements += sequenceElement;
            }*/
            sequenceElements += activate.umlElements->flattenSequenceElements(); // TODO assertion
        }
        else {
            log("discarded");
        }
    };
    return sequenceElements;
}

mapping Alternative::flattenAlternative():Alternative {
    self.umlElements->flattenSequenceElements()->forEach(sequenceElement) {
        result.umlElements += sequenceElement;
        log("Added element here");
        var useLeft : UseLeft := sequenceElement.oclAsType(UseLeft);
    };
    if (self.elseBlocks->size() > 0) {
        result.elseBlocks += self.elseBlocks->at(1).oclAsType(Else).map flattenElse();
    };
    result.text := self.text;
}

mapping Else::flattenElse():Else {
    result.umlElements += self.umlElements->flattenSequenceElements();
    result.text := self.text;
}

mapping Request::request2httpRequest(): HttpRequest {
    httpMethod := self.method;
    url := self.url;
    httprequestdatum += self.requestParam->map requestParam2httpRequestDatum();
}

mapping Response::response2httpResponse(): HttpResponse {
    httpStatus := self.code->toString();
    httpresponsedatum += self.extractParam->map extractParam2httpResponseDatum();
}

mapping RequestParam::requestParam2httpRequestDatum():HttpRequestDatum {
    variableName := self.name;
    value := self.value;
}

mapping ExtractParam::extractParam2httpResponseDatum():HttpResponseDatum {
    variableName := self.name;
    xPath := self.value;
}
