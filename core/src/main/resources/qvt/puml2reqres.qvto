modeltype puml "strict" uses puml('http://www.eclipse.plantuml/Puml');
modeltype reqres "strict" uses RequestResponsePairs('http://www.example.org/RequestResponsePairs');
modeltype Ecore "strict" uses 'http://www.eclipse.org/emf/2002/Ecore';

configuration property diagramName : String;

transformation puml2reqres(in input: puml, out output: reqres);

main() {
    log('Started transforming PlantUML to RequestResponse pairs');
    log(diagramName);

    assert fatal ( input.objectsOfType(UmlDiagram).umlDiagrams[SequenceUml]->size() = 1 )
        with log('Input does not contain exactly one SequenceDiagram');

     input.objectsOfType(UmlDiagram).umlDiagrams[SequenceUml].map transformUmlDiagram();
}

mapping SequenceUml::transformUmlDiagram(): Scenario {
    scenarioName := diagramName;

    var roundtripId : Integer := 1;

    var umlElements := self.umlElements;
    var umlElementsSize : Integer := umlElements->size();
    log ("", umlElementsSize);
    var umlElementsIndex : Integer := 1;

    while (umlElementsIndex <= umlElementsSize) {
        var sequenceElement : SequenceElement := umlElements->at(umlElementsIndex);
        if (sequenceElement.oclIsTypeOf(UseLeft)) {
            log("Found request");
            var useLeft : UseLeft := sequenceElement.oclAsType(UseLeft);
            assert fatal ( useLeft.content != null )
                with log ( 'UseLeft needs to contain content');
            var requestresponse : RequestResponse := useLeft.content;
            assert fatal ( requestresponse.oclIsTypeOf(Request) )
                with log ( 'Requestresponse needs to be a request');
            var request : Request := requestresponse.oclAsType(Request);
            var roundtripElement : Roundtrip := new Roundtrip();
            roundtripElement.roundtripName := "roundtrip" + roundtripId.toString();
            var httpRequestElement : HttpRequest := request.request2httpRequest();
            httpRequestElement.receiver := useLeft.userTwo.name;
            roundtripElement.httprequest := httpRequestElement;

            var foundResponse : Boolean := false;
            while (not foundResponse) {
                umlElementsIndex := umlElementsIndex + 1;
                sequenceElement := umlElements->at(umlElementsIndex);
                if (sequenceElement.oclIsTypeOf(Activate)) {
                    log("HELLO");
                    var activate : Activate := sequenceElement.oclAsType(Activate);
                    useLeft := activate.umlElements[UseLeft]->at(1);
                    assert fatal ( useLeft.content != null )
                        with log ( 'UseLeft needs to contain content');
                    requestresponse := useLeft.content;
                    assert fatal ( requestresponse.oclIsTypeOf(Response) )
                        with log ( 'Requestresponse needs to be a response');
                    var response : Response := requestresponse.oclAsType(Response);
                    roundtripElement.httpresponse := response.response2httpResponse();
                    foundResponse := true;
                }
            };
            roundtrip := roundtripElement;
        }
        elif (sequenceElement.oclIsTypeOf(Alternative)) {
        };
        log("Found nothing");
        umlElementsIndex := umlElementsIndex + 1;
    };


}

mapping Request::request2httpRequest(): HttpRequest {
    httpMethod := self.method;
    url := self.url;
    httprequestdatum += self.requestParam->map requestParam2httpRequestDatum();
}

mapping Response::response2httpResponse(): HttpResponse {
    httpStatus := self.code->toString();
    httpresponsedatum += self.extractParam->map extractParam2httpResponseDatum();
}

mapping RequestParam::requestParam2httpRequestDatum():HttpRequestDatum {
    variableName := self.name;
    value := self.value;
}

mapping ExtractParam::extractParam2httpResponseDatum():HttpResponseDatum {
    variableName := self.name;
    xPath := self.value;
}
